#!/usr/bin/env python3

import sys
import os
from typing import List, Dict
from lexer import Lexer
from parser import Parser, Program, VarDecl, ConstDecl, Assignment, Print, IfStatement, WhileStatement, FuncDecl, FuncCall, Include, ASTNode

class UHighCompiler:
    def __init__(self):
        self.variables: Dict[str, int] = {}
        self.label_counter: int = 0
        self.current_reg: int = 0
        self.string_counter: int = 0
        self.strings: Dict[str, int] = {}
        self.output: List[str] = []
        self.next_mem_addr = 100  # Start at memory address 100
        self.const_variables: Dict[str, bool] = {}  # Track constant variables
        self.in_loop = False
        self.current_loop_start = None
        self.current_loop_end = None
        self.loop_stack = []  # For nested loops
        self.block_stack = []  # Track all blocks (if/while)
        self.current_block_end = None
        self.header_added = False  # Track if header is added
        self.current_function = None  # Track current function scope
        self.function_strings = {}    # Store strings per function: {function_name: {string: addr}}
        self.string_lengths = {}   # Track string lengths for memory allocation

    def get_next_reg(self) -> str:
        reg = f"R{self.current_reg}"
        self.current_reg += 1
        if self.current_reg > 14:  # Keep space for R15 as temp
            self.current_reg = 0
        return reg

    def get_next_label(self) -> str:
        label = f"L{self.label_counter}"
        self.label_counter += 1
        return label

    def get_string_address(self, string: str) -> int:
        # Create function strings dict if it doesn't exist
        if self.current_function not in self.function_strings:
            self.function_strings[self.current_function] = {}

        # Check if string exists in current function scope
        func_strings = self.function_strings[self.current_function]
        if string not in func_strings:
            # Allocate memory based on string length (add 1 for null terminator)
            func_strings[string] = self.next_mem_addr
            self.string_lengths[string] = len(string) + 1
            self.next_mem_addr += len(string) + 1
        return func_strings[string]

    def collect_strings(self, program: Program):
        """Pre-process to collect all strings in the program"""
        def process_node(node):
            if isinstance(node, Print) and isinstance(node.value, str) and node.value.startswith('"'):
                self.get_string_address(node.value[1:-1])
            elif isinstance(node, VarDecl) and isinstance(node.initial_value, str) and node.initial_value.startswith('"'):
                self.get_string_address(node.initial_value[1:-1])
            elif isinstance(node, Assignment) and isinstance(node.value, str) and node.value.startswith('"'):
                self.get_string_address(node.value[1:-1])
            elif isinstance(node, IfStatement):
                for stmt in node.true_block:
                    process_node(stmt)
                if node.false_block:
                    for stmt in node.false_block:
                        process_node(stmt)
            elif isinstance(node, WhileStatement):
                for stmt in node.body:
                    process_node(stmt)
            elif isinstance(node, FuncDecl):
                for stmt in node.body:
                    process_node(stmt)

        for statement in program.statements:
            process_node(statement)

    def compile(self, source: str, base_dir: str = '.') -> str:
        self.base_dir = base_dir
        self.current_function = 'global'  # Default scope for top-level code
        
        lexer = Lexer(source)
        tokens = lexer.tokenize()
        parser = Parser(tokens)
        program = parser.parse()
        
        # Reset compiler state
        self.output = []
        self.header_added = False
        self.function_strings = {}
        
        # Add header
        if not self.header_added:
            self.output.extend([
                "// Generated by μHigh Compiler",
                '#include "stdio.io"',
                ""
            ])
            self.header_added = True

        # Compile the program
        self.compile_program(program)
        
        return '\n'.join(self.output)

    def compile_program(self, program: Program):
        if not self.header_added:
            self.output.extend([
                "// Generated by μHigh Compiler",
                '#include "stdio.io"',
                ""
            ])
            self.header_added = True

        # Process includes first
        includes = []
        statements = []
        for statement in program.statements:
            if isinstance(statement, Include):
                includes.append(statement)
            else:
                statements.append(statement)

        # Handle includes
        for include in includes:
            include_path = os.path.join(self.base_dir, include.filename[1:-1])  # Remove quotes
            with open(include_path, 'r') as f:
                included_source = f.read()
            lexer = Lexer(included_source)
            parser = Parser(lexer.tokenize())
            included_program = parser.parse()
            self.compile_program(included_program)

        # Process remaining statements
        for statement in statements:
            self.compile_statement(statement)

    def compile_statement(self, statement: ASTNode):
        if isinstance(statement, VarDecl):
            self.variables[statement.name] = len(self.variables)
            if statement.initial_value is not None:
                dest_reg = f"R{self.variables[statement.name]}"
                if isinstance(statement.initial_value, int):
                    self.output.append(f"MOV {dest_reg} {statement.initial_value}")
                elif isinstance(statement.initial_value, str) and statement.initial_value.startswith('"'):
                    addr = self.get_string_address(statement.initial_value[1:-1])
                    self.output.append(f"MOV {dest_reg} ${addr}")
                else:
                    result_reg = self.compile_expression(statement.initial_value)
                    if result_reg != dest_reg:
                        self.output.append(f"MOV {dest_reg} {result_reg}")
        elif isinstance(statement, ConstDecl):
            self.variables[statement.name] = len(self.variables)
            self.const_variables[statement.name] = True
            self.output.append(f"MOV R{self.variables[statement.name]} {statement.value}")
        elif isinstance(statement, Assignment):
            dest_reg = f"R{self.variables[statement.name]}"
            if isinstance(statement.value, int):
                self.output.append(f"MOV {dest_reg} {statement.value}")
            elif isinstance(statement.value, str) and statement.value.startswith('"'):
                addr = self.get_string_address(statement.value[1:-1])
                self.output.append(f"MOV {dest_reg} ${addr}")
            else:
                result_reg = self.compile_expression(statement.value)
                if result_reg != dest_reg:  # Only generate MOV if registers are different
                    self.output.append(f"MOV {dest_reg} {result_reg}")
        elif isinstance(statement, Print):
            if isinstance(statement.value, str) and statement.value.startswith('"'):
                string_content = statement.value[1:-1]
                addr = self.get_string_address(string_content)
                self.output.extend([
                    f"MOV RAX 1",
                    f"MOV RBX {addr}", # Address of string, never use $ addr for printf, stdio.io does that
                    f"CALL #printf"
                ])
            else:
                reg = self.compile_expression(statement.value)
                self.output.extend([
                    f"MOV RAX 1",
                    f"MOV RBX {reg}",
                    f"CALL #printint"
                ])
        elif isinstance(statement, IfStatement):
            else_label = self.get_next_label()
            end_label = self.get_next_label()
            condition_code = self.compile_condition(statement.condition, else_label)
            self.output.extend(condition_code)
            for stmt in statement.true_block:
                self.compile_statement(stmt)
            self.output.append(f"JMP #{end_label}")
            self.output.append(f"LBL {else_label}")
            if statement.false_block:
                for stmt in statement.false_block:
                    self.compile_statement(stmt)
            self.output.append(f"LBL {end_label}")
        elif isinstance(statement, WhileStatement):
            start_label = self.get_next_label()
            end_label = self.get_next_label()
            self.output.append(f"LBL {start_label}")
            condition_code = self.compile_condition(statement.condition, end_label)
            self.output.extend(condition_code)
            for stmt in statement.body:
                self.compile_statement(stmt)
            self.output.append(f"JMP #{start_label}")
            self.output.append(f"LBL {end_label}")
        elif isinstance(statement, FuncDecl):
            self.current_function = statement.name
            # Output function label
            self.output.append(f"LBL {statement.name}")

            # Collect strings in the function body first
            self.collect_strings_in_block(statement.body)
            
            # Output string definitions for this function
            if self.current_function in self.function_strings:
                for string, addr in self.function_strings[self.current_function].items():
                    # Add string length as a comment for clarity
                    self.output.append(f'    ;; Length: {self.string_lengths[string]} bytes')
                    self.output.append(f'    DB ${addr} "{string}"')
                if self.function_strings[self.current_function]:
                    self.output.append("")  # Empty line after string definitions
            
            # Compile function body
            for stmt in statement.body:
                self.compile_statement(stmt)
            
            self.current_function = None  # Reset current function
        elif isinstance(statement, FuncCall):
            self.output.append(f"CALL #{statement.name}")

    def compile_condition(self, condition: Union[str, int], false_label: str) -> List[str]:
        ops = {
            "==": "JNE",
            "!=": "JE",
            "<": "JGE",
            ">": "JLE",
            "<=": "JG",
            ">=": "JL"
        }
        
        if isinstance(condition, str):
            left, op, right = re.split(r'(\W+)', condition)
            left = left.strip()
            op = op.strip()
            right = right.strip()
            
            if op not in ops:
                raise ValueError(f"Invalid condition operator: {op}")
            
            # Check if both sides are strings or variables containing strings
            if (left.startswith('"') and right.startswith('"')) or (left in self.variables and right.startswith('"')):
                left_addr = self.get_string_address(left[1:-1]) if left.startswith('"') else f"R{self.variables[left]}"
                right_addr = self.get_string_address(right[1:-1]) if right.startswith('"') else f"R{self.variables[right]}"
                return [
                    f"MNI StringOperations.cmp {left_addr} {right_addr}",
                    f"{ops[op]} #{false_label}"
                ]
            
            # Clear temporary instructions
            saved_output = self.output
            self.output = []
            
            # Compile both sides
            left_reg = self.compile_expression(left)
            left_instrs = self.output
            
            self.output = []
            right_reg = self.compile_expression(right)
            right_instrs = self.output
            
            # Restore output and return compiled condition
            self.output = saved_output
            
            return [
                *left_instrs,
                *right_instrs,
                f"CMP {left_reg} {right_reg}",
                f"{ops[op]} #{false_label}"
            ]
        
        raise ValueError(f"Invalid condition: {condition}")

    def compile_expression(self, expr: str) -> str:
        expr = expr.strip()
        
        # Simple variable, constant, or number
        if expr.isdigit():
            reg = self.get_next_reg()
            self.output.append(f"MOV {reg} {expr}")
            return reg
            
        if expr in self.variables:
            reg = self.get_next_reg()
            self.output.append(f"MOV {reg} R{self.variables[expr]}")
            return reg

        if expr in self.const_variables:
            return f"R{self.variables[expr]}"

        # Basic arithmetic
        ops = {'+': 'ADD', '-': 'SUB', '*': 'MUL', '/': 'DIV'}
        for op in ops:
            if op in expr:
                left, right = [x.strip() for x in expr.split(op, 1)]
                left_reg = self.compile_expression(left)
                right_reg = self.compile_expression(right)
                result_reg = self.get_next_reg()
                if left_reg != result_reg:
                    self.output.append(f"MOV {result_reg} {left_reg}")
                self.output.append(f"{ops[op]} {result_reg} {right_reg}")
                return result_reg

        raise ValueError(f"Invalid expression: {expr}")

    def collect_strings_in_block(self, statements: List[ASTNode]):
        """Collect all strings used in a block of statements"""
        for stmt in statements:
            if isinstance(stmt, Print) and isinstance(stmt.value, str) and stmt.value.startswith('"'):
                self.get_string_address(stmt.value[1:-1])
            elif isinstance(stmt, VarDecl) and isinstance(stmt.initial_value, str) and stmt.initial_value.startswith('"'):
                self.get_string_address(stmt.initial_value[1:-1])
            elif isinstance(stmt, Assignment) and isinstance(stmt.value, str) and stmt.value.startswith('"'):
                self.get_string_address(stmt.value[1:-1])
            elif isinstance(stmt, IfStatement):
                self.collect_strings_in_block(stmt.true_block)
                if stmt.false_block:
                    self.collect_strings_in_block(stmt.false_block)
            elif isinstance(stmt, WhileStatement):
                self.collect_strings_in_block(stmt.body)

def main():
    if len(sys.argv) != 2:
        print("Usage: uhigh.py <source_file>")
        sys.exit(1)

    source_file = sys.argv[1]
    base_dir = os.path.dirname(source_file)

    with open(source_file, 'r') as f:
        source = f.read()

    compiler = UHighCompiler()
    output = compiler.compile(source, base_dir)
    
    output_file = source_file.replace('.uh', '.masm')
    with open(output_file, 'w') as f:
        f.write(output)

if __name__ == "__main__":
    main()
