#!/usr/bin/env python3
import re
import sys
import os
from typing import List, Dict, Union
from lexer import Lexer
from parser import Parser, Program, VarDecl, ConstDecl, Assignment, Print, IfStatement, WhileStatement, FuncDecl, FuncCall, Include, ASTNode, InlineAsm
import argparse
from argparse import ArgumentParser

class UHighCompiler:
    def __init__(self):
        self.variables: Dict[str, int] = {}
        self.label_counter: int = 0
        self.current_reg: int = 0
        self.string_counter: int = 0
        self.strings: Dict[str, int] = {}
        self.output: List[str] = []
        self.next_mem_addr = 100  # Start at memory address 100
        self.const_variables: Dict[str, bool] = {}  # Track constant variables
        self.in_loop = False
        self.current_loop_start = None
        self.current_loop_end = None
        self.loop_stack = []  # For nested loops
        self.block_stack = []  # Track all blocks (if/while)
        self.current_block_end = None
        self.header_added = False  # Track if header is added
        self.current_function = None  # Track current function scope
        self.function_strings = {}    # Store strings per function: {function_name: {string: addr}}
        self.string_lengths = {}   # Track string lengths for memory allocation
        self.indent_level = 0  # Track the current indentation level

    def increase_indent(self):
        """Increase the indentation level."""
        self.indent_level += 1

    def decrease_indent(self):
        """Decrease the indentation level."""
        if self.indent_level > 0:
            self.indent_level -= 1

    def add_line(self, line: str):
        """Add a line to the output with proper indentation."""
        indent = '    ' * self.indent_level  # Use 4 spaces per indent level
        self.output.append(f"{indent}{line}")

    def get_next_reg(self) -> str:
        reg = f"R{self.current_reg}"
        self.current_reg += 1
        if self.current_reg > 14:  # Keep space for R15 as temp
            self.current_reg = 0
        return reg

    def get_next_label(self) -> str:
        label = f"L{self.label_counter}"
        self.label_counter += 1
        return label

    def get_string_address(self, string: str) -> int:
        # Create function strings dict if it doesn't exist
        if self.current_function not in self.function_strings:
            self.function_strings[self.current_function] = {}

        # Check if string exists in current function scope
        func_strings = self.function_strings[self.current_function]
        if string not in func_strings:
            # Allocate memory based on string length (add 1 for null terminator)
            func_strings[string] = self.next_mem_addr
            self.string_lengths[string] = len(string) + 1
            self.next_mem_addr += len(string) + 1
        return func_strings[string]

    def collect_strings(self, program: Program):
        """Pre-process to collect all strings in the program"""
        def process_node(node):
            if isinstance(node, Print):
                for value in node.values:
                    if isinstance(value, str) and value.startswith('"'):
                        self.get_string_address(value[1:-1])
            elif isinstance(node, VarDecl) and isinstance(node.initial_value, str) and node.initial_value.startswith('"'):
                self.get_string_address(node.initial_value[1:-1])
            elif isinstance(node, Assignment) and isinstance(node.value, str) and node.value.startswith('"'):
                self.get_string_address(node.value[1:-1])
            elif isinstance(node, IfStatement):
                for stmt in node.true_block:
                    process_node(stmt)
                if node.false_block:
                    for stmt in node.false_block:
                        process_node(stmt)
            elif isinstance(node, WhileStatement):
                for stmt in node.body:
                    process_node(stmt)
            elif isinstance(node, FuncDecl):
                for stmt in node.body:
                    process_node(stmt)

        for statement in program.statements:
            process_node(statement)

    def compile(self, source: str, base_dir: str = '.') -> str:
        self.base_dir = base_dir
        self.current_function = 'global'  # Default scope for top-level code
        
        lexer = Lexer(source)
        tokens = lexer.tokenize()
        parser = Parser(tokens)
        program = parser.parse()
        
        # Reset compiler state
        self.output = []
        self.header_added = False
        self.function_strings = {}
        
        # Add header
        if not self.header_added:
            self.add_line(";;;;;; Generated by μHigh Compiler")
            self.add_line('#include "stdio.print"')
            self.add_line("")
            self.header_added = True

        # Compile the program
        self.compile_program(program)
        
        return '\n'.join(self.output)

    def compile_program(self, program: Program):
        if not self.header_added:
            self.add_line("// Generated by μHigh Compiler")
            self.add_line('#include "stdio.print"')
            self.add_line("")
            self.header_added = True
 
        # Collect all strings in the program first
        self.collect_strings(program)

        # Process includes first
        includes = []
        statements = []
        for statement in program.statements:
            if isinstance(statement, Include):
                includes.append(statement)
            else:
                statements.append(statement)

        # Handle includes
        for include in includes:
            include_path = os.path.join(self.base_dir, include.filename[1:-1])  # Remove quotes
            with open(include_path, 'r') as f:
                included_source = f.read()
            lexer = Lexer(included_source)
            parser = Parser(lexer.tokenize())
            included_program = parser.parse()
            self.compile_program(included_program)

        # Process remaining statements
        for statement in statements:
            if isinstance(statement, FuncDecl) and statement.name == "main":
                self.add_line(f"LBL {statement.name}")
                self.increase_indent()

                # Output string definitions for the main function
                if "global" in self.function_strings:
                    for string, addr in self.function_strings["global"].items():
                        self.add_line(f'    ;; Length: {self.string_lengths[string]} bytes')
                        self.add_line(f'    DB ${addr} "{string}"')
                    if self.function_strings["global"]:
                        self.add_line("")  # Empty line after string definitions

                # Compile the main function body
                for stmt in statement.body:
                    self.compile_statement(stmt)

                # Add HLT at the end of main
                self.add_line("HLT")

                self.decrease_indent()
                self.decrease_indent()
            else:
                self.compile_statement(statement)

    def compile_statement(self, statement: ASTNode):
        if isinstance(statement, VarDecl):
            self.variables[statement.name] = len(self.variables)
            if statement.initial_value is not None:
                dest_reg = f"R{self.variables[statement.name]}"
                if isinstance(statement.initial_value, int):
                    self.add_line(f"  MOV {dest_reg} {statement.initial_value}")
                elif isinstance(statement.initial_value, str) and statement.initial_value.startswith('"'):
                    addr = self.get_string_address(statement.initial_value[1:-1])
                    self.add_line(f"  MOV {dest_reg} ${addr}")
                else:
                    result_reg = self.compile_expression(statement.initial_value)
                    if result_reg != dest_reg:
                        self.add_line(f"  MOV {dest_reg} {result_reg}")
        elif isinstance(statement, ConstDecl):
            self.variables[statement.name] = len(self.variables)
            self.const_variables[statement.name] = True
            self.add_line(f"  MOV R{self.variables[statement.name]} {statement.value}")
        elif isinstance(statement, Assignment):
            dest_reg = f"R{self.variables[statement.name]}"
            if isinstance(statement.value, int):
                self.add_line(f"  MOV {dest_reg} {statement.value}")
            elif isinstance(statement.value, str) and statement.value.startswith('"'):
                addr = self.get_string_address(statement.value[1:-1])
                self.add_line(f"  MOV {dest_reg} ${addr}")
            else:
                result_reg = self.compile_expression(statement.value)
                if result_reg != dest_reg:  # Only generate MOV if registers are different
                    self.add_line(f"  MOV {dest_reg} {result_reg}")
        elif isinstance(statement, Print):
            # Check if the first value is a variable or constant
            if len(statement.values) == 1:
                value = statement.values[0]
                if isinstance(value, int):
                    # Directly print the integer
                    reg = self.get_next_reg()
                    self.add_line(f"  MOV {reg} {value}")
                    self.add_line(f"  MOV RAX 1")
                    self.add_line(f"  MOV RBX {reg}")
                    self.add_line(f"  CALL #printint")
                    # check if it' a variable then use printint for int type or printf for string type
                    
                elif isinstance(value, str) and value.startswith('"'):
                    # Directly print the string
                    addr = self.get_string_address(value[1:-1])
                    self.add_line(f"  MOV RAX 1")
                    self.add_line(f"  MOV RBX {addr}")
                    self.add_line(f"  CALL #printf")
                elif isinstance(value, str) and value in self.const_variables:
                    # Directly print the constant variable
                    reg = f"R{self.variables[value]}"
                    self.add_line(f"  MOV RAX 1")
                    self.add_line(f"  MOV RBX {reg}")
                    self.add_line(f"  CALL #printint")
                
                
                
                elif isinstance(value, str) and value in self.variables:
                    # Check if the variable is an integer or string
                    if isinstance(self.variables[value], int):
                        # Use printint for integer variables
                        reg = f"R{self.variables[value]}"
                        self.add_line(f"  MOV RAX 1")
                        self.add_line(f"  MOV RBX {reg}")
                        self.add_line(f"  CALL #printint")
                    else:
                        # Use printf for string variables
                        reg = f"R{self.variables[value]}"
                        self.add_line(f"  MOV RAX 1")
                        self.add_line(f"  MOV RBX {reg}")
                        self.add_line(f"  CALL #printf")
                else:
                    # Fallback to formatted string handling
                    fmt = value
                    fmt_addr = self.get_string_address(fmt[1:-1]) if isinstance(fmt, str) and fmt.startswith('"') else fmt
                    formatted_addr = self.get_next_reg()
                    self.add_line(f"  MNI Memory.allocate {formatted_addr} 256")
                    self.add_line(f"  MNI StringOperations.format {formatted_addr} {fmt_addr}")
                    self.add_line(f"  MOV RAX 1")
                    self.add_line(f"  MOV RBX {formatted_addr}")
                    self.add_line(f"  CALL #printf")
            else:
                # Handle multiple arguments (fallback to formatted string handling)
                fmt = statement.values[0]
                fmt_addr = self.get_string_address(fmt[1:-1]) if isinstance(fmt, str) and fmt.startswith('"') else fmt
                arg_addrs = []

                # Collect addresses of arguments
                for arg in statement.values[1:]:
                    if isinstance(arg, int):
                        reg = self.get_next_reg()
                        self.add_line(f"  MOV {reg} {arg}")
                        arg_addrs.append(reg)
                    elif isinstance(arg, str) and arg.startswith('"'):
                        addr = self.get_string_address(arg[1:-1])
                        arg_addrs.append(f"${addr}")
                    else:
                        reg = self.compile_expression(arg)
                        arg_addrs.append(reg)

                # Allocate memory for the formatted string
                formatted_addr = self.get_next_reg()
                self.add_line(f"  MNI Memory.allocate {formatted_addr} 256")

                # Call MNI StringOperations.format
                self.add_line(f"  MNI StringOperations.format {formatted_addr} {fmt_addr} {' '.join(arg_addrs)}")

                # Pass the formatted string to printf
                self.add_line(f"  MOV RAX 1")
                self.add_line(f"  MOV RBX {formatted_addr}")
                self.add_line(f"  CALL #printf")
        elif isinstance(statement, IfStatement):
            unique_id = self.label_counter
            true_label = f"if_true_{unique_id}"
            false_label = f"if_false_{unique_id}"
            end_label = f"if_end_{unique_id}"
            self.label_counter += 1

            # Collect strings in both true and false blocks
            self.collect_strings_in_block(statement.true_block)
            if statement.false_block:
                self.collect_strings_in_block(statement.false_block)

            condition_code = self.compile_condition(statement.condition, false_label)
            self.output.extend(condition_code)
            self.add_line(f"LBL {true_label}")
            self.increase_indent()
            for stmt in statement.true_block:
                self.compile_statement(stmt)
            self.decrease_indent()
            self.add_line(f"  JMP #{end_label}")
            self.add_line(f"  LBL {false_label}")
            if statement.false_block:
                self.increase_indent()
                for stmt in statement.false_block:
                    self.compile_statement(stmt)
                self.decrease_indent()
            self.add_line(f"LBL {end_label}")
        elif isinstance(statement, WhileStatement):
            start_label = self.get_next_label()
            end_label = self.get_next_label()
            self.add_line(f"LBL {start_label}")
            # Assume condition is of the form 'x < y' or similar
            cond = statement.condition
            if isinstance(cond, str) and any(op in cond for op in ['<', '>', '==', '!=', '<=', '>=']):
                # Parse condition string
                parts = cond.split()
                left, op, right = parts[0], parts[1], parts[2]
                reg_left = left if left.startswith('R') else (f"R{self.variables[left]}" if left in self.variables else left)
                reg_right = right if right.startswith('R') else (f"R{self.variables[right]}" if right in self.variables else right)
                self.add_line(f"  MOV R1 {reg_left}")
                self.add_line(f"  MOV R2 {reg_right}")
                self.add_line(f"  CMP R1 R2")
                if op == '<':
                    self.add_line(f"  JGE #{end_label}")
                elif op == '>':
                    self.add_line(f"  JLE #{end_label}")
                elif op == '==':
                    self.add_line(f"  JNE #{end_label}")
                elif op == '!=':
                    self.add_line(f"  JE #{end_label}")
                elif op == '<=':
                    self.add_line(f"  JG #{end_label}")
                elif op == '>=':
                    self.add_line(f"  JL #{end_label}")
            else:
                # Fallback: treat as boolean variable
                reg_cond = cond if cond.startswith('R') else (f"R{self.variables[cond]}" if cond in self.variables else cond)
                self.add_line(f"  CMP {reg_cond} 0")
                self.add_line(f"  JE #{end_label}")
            for stmt in statement.body:
                self.compile_statement(stmt)
            self.add_line(f"  JMP #{start_label}")
            self.add_line(f"LBL {end_label}")
        elif isinstance(statement, FuncDecl):
            self.current_function = statement.name
            self.add_line(f"LBL {statement.name}")

            # Stack-based argument handling
            if hasattr(statement, 'parameters') and statement.parameters:
                for i, param in enumerate(statement.parameters):
                    reg = f"R{i}"
                    self.add_line(f"  POP {reg}")
                    self.variables[param] = i

            # Collect strings in the function body first
            self.collect_strings_in_block(statement.body)
            # Output string definitions for this function
            if self.current_function in self.function_strings:
                for string, addr in self.function_strings[self.current_function].items():
                    self.add_line(f'    ;; Length: {self.string_lengths[string]} bytes')
                    self.add_line(f'    DB ${addr} "{string}"')
                if self.function_strings[self.current_function]:
                    self.add_line("")  # Empty line after string definitions
            # Compile function body
            self.increase_indent()
            for stmt in statement.body:
                self.compile_statement(stmt)
            self.decrease_indent()
            self.current_function = None  # Reset current function
        elif isinstance(statement, FuncCall):
            # Stack-based argument passing
            if hasattr(statement, 'args') and statement.args:
                for arg in reversed(statement.args):
                    if isinstance(arg, int):
                        reg = self.get_next_reg()
                        self.add_line(f"  MOV {reg} {arg}")
                        self.add_line(f"  PUSH {reg}")
                    elif isinstance(arg, str) and arg in self.variables:
                        reg = f"R{self.variables[arg]}"
                        self.add_line(f"  PUSH {reg}")
                    else:
                        reg = self.compile_expression(arg)
                        self.add_line(f"  PUSH {reg}")
            self.add_line(f"  CALL #{statement.name}")
        elif isinstance(statement, InlineAsm):
            # Add inline assembly code directly to the output
            # Prefix with a comment indicating it's inline assembly
            self.add_line(f"    ; Inline μHigh assembly block")
            
            # Process each line of assembly code
            lines = statement.code.split('\n')
            for line in lines:
                stripped = line.strip()
                if stripped:  # Skip empty lines
                    # Don't add extra indentation for comment lines
                    if stripped.startswith(';'):
                        self.add_line(f"    {stripped}")
                    else:
                        self.add_line(f"    {stripped}")
            
            self.add_line("")  # Add an empty line after the assembly block

    def compile_condition(self, condition: Union[str, int], false_label: str) -> List[str]:
        ops = {
            "==": "JNE",
            "!=": "JE",
            "<": "JGE",
            ">": "JLE",
            "<=": "JG",
            ">=": "JL"
        }
        
        if isinstance(condition, str):
            # Use regex to match left, operator, right
            match = re.match(r'^(.*?)\s*(==|!=|<=|>=|<|>)\s*(.*)$', condition)
            if not match:
                raise ValueError(f"Invalid condition format: {condition}")
            left, op, right = match.groups()
            left = left.strip()
            op = op.strip()
            right = right.strip()
            
            if op not in ops:
                raise ValueError(f"Invalid condition operator: {op}")
            
            # Check if both sides are strings or variables containing strings
            if (left.startswith('"') and right.startswith('"')) or (left in self.variables and right.startswith('"')):
                left_addr = self.get_string_address(left[1:-1]) if left.startswith('"') else f"R{self.variables[left]}"
                right_addr = self.get_string_address(right[1:-1]) if right.startswith('"') else f"R{self.variables[right]}"
                return [
                    f"    MNI StringOperations.cmp {left_addr} {right_addr}",
                    f"    {ops[op]} #{false_label}"
                ]
            
            # Clear temporary instructions
            saved_output = self.output
            self.output = []
            
            # Compile both sides
            left_reg = self.compile_expression(left)
            left_instrs = self.output
            
            self.output = []
            right_reg = self.compile_expression(right)
            right_instrs = self.output
            
            # Restore output and return compiled condition
            self.output = saved_output
            
            return [
                *left_instrs,
                *right_instrs,
                f"    CMP {left_reg} {right_reg}",
                f"    {ops[op]} #{false_label}"
            ]
        
        raise ValueError(f"Invalid condition: {condition}")

    def compile_expression(self, expr: str) -> str:
        expr = expr.strip()
        
        # Simple variable, constant, or number
        if expr.isdigit():
            reg = self.get_next_reg()
            self.add_line(f"MOV {reg} {expr}")
            return reg
            
        if expr in self.variables:
            reg = self.get_next_reg()
            self.add_line(f"MOV {reg} R{self.variables[expr]}")
            return reg

        if expr in self.const_variables:
            return f"R{self.variables[expr]}"

        # Basic arithmetic
        ops = {'+': 'ADD', '-': 'SUB', '*': 'MUL', '/': 'DIV'}
        for op in ops:
            if op in expr:
                left, right = [x.strip() for x in expr.split(op, 1)]
                left_reg = self.compile_expression(left)
                right_reg = self.compile_expression(right)
                result_reg = self.get_next_reg()
                if left_reg != result_reg:
                    self.add_line(f"MOV {result_reg} {left_reg}")
                self.add_line(f"{ops[op]} {result_reg} {right_reg}")
                return result_reg

        raise ValueError(f"Invalid expression: {expr}")

    def collect_strings_in_block(self, statements: List[ASTNode]):
        for stmt in statements:
            if isinstance(stmt, Print):
                for val in stmt.values:
                    if isinstance(val, str) and val.startswith('"'):
                        self.get_string_address(val[1:-1])
            elif hasattr(stmt, 'body') and isinstance(stmt.body, list):
                self.collect_strings_in_block(stmt.body)
            elif hasattr(stmt, 'true_block') and isinstance(stmt.true_block, list):
                self.collect_strings_in_block(stmt.true_block)
            elif hasattr(stmt, 'false_block') and isinstance(stmt.false_block, list):
                self.collect_strings_in_block(stmt.false_block)

def main():
    parser = argparse.ArgumentParser(description="μHigh Compiler")
    parser.add_argument("source_file", help="Path to the source file")
    parser.add_argument("-d", "--debug", action="store_true", help="Enable debugging mode")
    args = parser.parse_args()

    source_file = args.source_file
    base_dir = os.path.dirname(source_file)

    with open(source_file, 'r') as f:
        source = f.read()

    compiler = UHighCompiler()
    parser = Parser(Lexer(source).tokenize(), debug=args.debug)
    program = parser.parse()

    output = compiler.compile(source, base_dir)

    output_file = source_file.replace('.uh', '.masm')
    with open(output_file, 'w', encoding="utf-8") as f:
        try:
            f.write(output)
        except Exception as e:
            print("Error writing output file:", e)
            print("Output so far:")
            print(output)

    if args.debug:
        print("Debugging information:")
        print("Compilation completed successfully.")

if __name__ == "__main__":
    main()
    print("Debugging information:")
    print("Compilation completed successfully.")

if __name__ == "__main__":
    main()
